<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
 <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
 <title>TRIO</title>
 <link href="trio.css" rel="stylesheet" type="text/css">
</head>
<body>
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">User-defined Formatted Printing Functions.</div>  </div>
</div><!--header-->
<div class="contents">

<p>Functions for using customized formatting specifiers.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gabef3fc9260a3dcb58fafeacca586661e"><td class="memItemLeft" align="right" valign="top">trio_pointer_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___user_defined.html#gabef3fc9260a3dcb58fafeacca586661e">trio_register</a> (trio_callback_t callback, const char *name)</td></tr>
<tr class="memdesc:gabef3fc9260a3dcb58fafeacca586661e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register new user-defined specifier.  <a href="#gabef3fc9260a3dcb58fafeacca586661e">More...</a><br/></td></tr>
<tr class="separator:gabef3fc9260a3dcb58fafeacca586661e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f3eaf6dcb41557d92f0f2236c4bcbb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___user_defined.html#ga8f3eaf6dcb41557d92f0f2236c4bcbb0">trio_unregister</a> (trio_pointer_t handle)</td></tr>
<tr class="memdesc:ga8f3eaf6dcb41557d92f0f2236c4bcbb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister an existing user-defined specifier.  <a href="#ga8f3eaf6dcb41557d92f0f2236c4bcbb0">More...</a><br/></td></tr>
<tr class="separator:ga8f3eaf6dcb41557d92f0f2236c4bcbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Functions for using customized formatting specifiers. </p>
<p><b>SYNOPSIS</b> </p>
<pre class="fragment">cc ... -ltrio -lm

#include &lt;trio.h&gt;
#include &lt;triop.h&gt;
</pre><p><b>DESCRIPTION</b> </p>
<p>This documentation is incomplete.</p>
<p><b>User-defined</b> <b>Specifier</b> </p>
<p>The user-defined specifier consists of a start character (\074 = '&lt;'), an optional namespace string followed by a namespace separator (\072 = ':'), a format string, an optional skipping separator (\174 = '|'), and an end character (\076 = '&gt;').</p>
<p>The namespace string can consist of alphanumeric characters, and is used to define a named reference (see below). The namespace is case-sensitive. If no namespace is specified, then we use an unnamed reference (see below).</p>
<p>The format can consist of any character except the end character ('&gt;'), the namespace separator (':'), the skipping separator ('|'), and the nil character (\000).</p>
<p>Any modifier can be used together with the user-defined specifier.</p>
<p>There are two formats for invoking a user-defined specifier. The first format is an extension of the normal printf/scanf formatting. It uses the percent character (\045 = '') followed by optional qualifiers and a specifier. For example:</p>
<pre class="fragment">  trio_printf("%&lt;format&gt;\n", my_handle, my_data);
</pre><p>Some C compilers can issue a warning if there is a mismatch between specifiers and arguments. Unfortunately, these warnings does not work with the first format for user-defined specifiers. Therefore the second format has been introduced. The second format can only be applied to user-defined specifiers.</p>
<p>The second format starts with a dollar character (\044 = '$') instead of the percent character, and is followed by optional qualifiers and the user-defined specifier. If the specifier contains a pipe character (\174 = '|'), then everything between the pipe character and the end character ('&gt;') is ignored. The ignored part can be used to list the normal specifiers that the C compiler uses to determine mismatches. For example:</p>
<pre class="fragment">  trio_printf("$&lt;format|%p%p&gt;\n", my_handle, my_data);
</pre><p><b>Registering</b> </p>
<p>A user-defined specifier must be registered before it can be used. Unregistered user-defined specifiers are ignored. The <a class="el" href="group___user_defined.html#gabef3fc9260a3dcb58fafeacca586661e">trio_register</a> function is used to register a user-defined specifier. It takes two argument, a callback function and a namespace, and it returns a handle. The handle must be used to unregister the specifier later.</p>
<p>The following example registers a user-define specifier with the "my_namespace" namespace:</p>
<pre class="fragment">  my_handle = trio_register(my_callback, "my_namespace");
</pre><p>There can only be one user-defined specifier with a given namespace. There can be an unlimited number (subject to maximum length of the namespace) of different user-defined specifiers.</p>
<p>Passing NULL as the namespace argument results in an anonymous reference. There can be an unlimited number of anonymous references.</p>
<p><b>REFERENCES</b> </p>
<p>There are two ways that a registered callback can be called. Either the user-defined specifier must contain the registered namespace in the format string, or the handle is passed as an argument to the formatted printing function.</p>
<p>If the namespace is used, then a user-defined pointer must be passed as an argument:</p>
<pre class="fragment">  trio_printf("%&lt;my_namespace:format&gt;\n", my_data);
</pre><p>If the handle is used, then the user-defined specifier must not contain a namespace. Instead the handle must be passed as an argument, followed by a user-defined pointer:</p>
<pre class="fragment">  trio_printf("%&lt;format&gt;\n", my_handle, my_data);
</pre><p>The two examples above are equivalent.</p>
<p>There must be exactly one user-defined pointer per user-defined specifier. This pointer can be used within the callback function with the trio_get_argument getter function (see below).</p>
<p>The format string is optional. It can be used within the callback function with the trio_get_format getter function.</p>
<p><b>Anonymous</b> <b>References</b> Anonymous references are specified by passing NULL as the namespace.</p>
<p>The handle must be passed as an argument followed by a user-defined pointer. No namespace can be specified.</p>
<pre class="fragment">  anon_handle = trio_register(callback, NULL);
  trio_printf("%&lt;format&gt;\n", anon_handle, my_data);
</pre><p><b>Restrictions</b> </p>
<ul>
<li>The length of the namespace string cannot exceed 63 characters. </li>
<li>The length of the user-defined format string cannot exceed 255 characters. </li>
<li>User-defined formatting cannot re-define existing specifiers. This restriction was imposed because the existing formatting specifiers have a well-defined behaviour, and any re-definition would apply globally to an application (imagine a third-party library changing the behaviour of a specifier that is crusial to your application).</li>
</ul>
<p><b>CALLBACK</b> <b>FUNCTION</b> </p>
<p>The callback function will be called if a matching user-defined specifier is found within the formatting string. The callback function takes one input parameter, an opaque reference which is needed by the private functions. It returns an <code>int</code>, which is currently ignored. The prototype is</p>
<pre class="fragment">  int (*trio_callback_t)(void *ref);
</pre><p>See the Example section for full examples.</p>
<p><b>PRINTING</b> <b>FUNCTIONS</b> </p>
<p>The following printing functions must only be used inside a callback function. These functions will print to the same output medium as the printf function which invoked the callback function. For example, if the user-defined specifier is used in an sprintf function, then these print functions will output their result to the same string.</p>
<p><b>Elementary</b> <b>Printing</b> </p>
<p>There are a number of function to print elementary data types.</p>
<ul>
<li>trio_print_int Print a signed integer. For example: <pre class="fragment">  trio_print_int(42);
</pre> </li>
<li>trio_print_uint Print an unsigned integer. </li>
<li>trio_print_double Print a floating-point number. </li>
<li>trio_print_string Print a string. For example: <pre class="fragment">  trio_print_string("Hello World");
  trio_print_string(trio_get_format());
</pre> </li>
<li>trio_print_pointer Print a pointer.</li>
</ul>
<p><b>Formatted</b> <b>Printing</b> </p>
<p>The functions trio_print_ref, trio_vprint_ref, and trio_printv_ref outputs a formatted string just like its printf equivalents.</p>
<pre class="fragment">  trio_print_ref(ref, "There are %d towels\n", 42);
  trio_print_ref(ref, "%&lt;recursive&gt;\n", recursive_writer, trio_get_argument(ref));
</pre><p><b>GETTER</b> <b>AND</b> <b>SETTER</b> <b>FUNCTIONS</b> </p>
<p>The following getter and setter functions must only be used inside a callback function. They can either operate on the modifiers or on special data.</p>
<p><b>Modifiers</b> </p>
<p>The value of a modifier, or a boolean indication of its presence or absence, can be found or set with the getter and setter functions. The generic prototypes of the these getter and setter functions are</p>
<pre class="fragment">  int  trio_get_???(void *ref);
  void trio_set_???(void *ref, int);
</pre><p>where <code></code>??? refers to a modifier. For example, to get the width of the user-defined specifier use</p>
<pre class="fragment">  int width = trio_get_width(ref);
</pre><p><b>Special</b> <b>Data</b> </p>
<p>Consider the following user-defined specifier, in its two possible referencing presentations.</p>
<pre class="fragment">  trio_printf("%&lt;format&gt;\n", namespace_writer, argument);
  trio_printf("%&lt;namespace:format&gt;\n", argument);
</pre><p>trio_get_format will get the <code>format</code> string, and trio_get_argument} will get the <code>argument</code> parameter. There are no associated setter functions.</p>
<p><b>EXAMPLES</b> </p>
<p>The following examples show various types of user-defined specifiers. Although each specifier is demonstrated in isolation, they can all co-exist within the same application.</p>
<p><b>Time</b> <b>Example</b> </p>
<p>Print the time in the format "HOUR:MINUTE:SECOND" if "time" is specified inside the user-defined specifier.</p>
<pre class="fragment">  static int time_print(void *ref)
  {
    const char *format;
    time_t *data;
    char buffer[256];

    format = trio_get_format(ref);
    if ((format) &amp;&amp; (strcmp(format, "time") == 0)) {
      data = trio_get_argument(ref);
      if (data == NULL)
        return -1;
      strftime(buffer, sizeof(buffer), "%H:%M:%S", localtime(data));
      trio_print_string(ref, buffer);
    }
    return 0;
  }
</pre><pre class="fragment">  int main(void)
  {
    void *handle;
    time_t now = time(NULL);

    handle = trio_register(time_print, "my_time");

    trio_printf("%&lt;time&gt;\n", handle, &amp;now);
    trio_printf("%&lt;my_time:time&gt;\n", &amp;now);

    trio_unregister(handle);
    return 0;
  }
</pre><p><b>Complex</b> <b>Numbers</b> <b>Example</b> </p>
<p>Consider a complex number consisting of a real part, re, and an imaginary part, im.</p>
<pre class="fragment">  struct Complex {
    double re;
    double im;
  };
</pre><p>This example can print such a complex number in one of two formats. The default format is "re + i im". If the alternative modifier is used, then the format is "r exp(i theta)", where r is the length of the complex vector (re, im) and theta is its angle.</p>
<pre class="fragment">  static int complex_print(void *ref)
  {
    struct Complex *data;
    const char *format;

    data = (struct Complex *)trio_get_argument(ref);
    if (data) {
      format = trio_get_format(ref);

      if (trio_get_alternative(ref)) {
        double r, theta;

        r = sqrt(pow(data-&gt;re, 2) + pow(data-&gt;im, 2));
        theta = acos(data-&gt;re / r);
        trio_print_ref(ref, "%#f exp(i %#f)", r, theta);

      } else {
        trio_print_ref(ref, "%#f + i %#f", data-&gt;re, data-&gt;im);
      }
    }
    return 0;
  }
</pre><pre class="fragment">  int main(void)
  {
    void *handle;

    handle = trio_register(complex_print, "complex");

    /* Normal format. With handle and the with namespace */
    trio_printf("%&lt;&gt;\n", handle, &amp;complex);
    trio_printf("%&lt;complex:&gt;\n", &amp;complex);
    /* In exponential notation */
    trio_printf("%#&lt;&gt;\n", handle, &amp;complex);
    trio_printf("%#&lt;complex:unused data&gt;\n", &amp;complex);

    trio_unregister(handle);
    return 0;
  }
</pre><p><b>RETURN</b> <b>VALUES</b> </p>
<p><a class="el" href="group___user_defined.html#gabef3fc9260a3dcb58fafeacca586661e">trio_register</a> returns a handle, or NULL if an error occured.</p>
<p><b>SEE</b> <b>ALSO</b> </p>
<p><a class="el" href="group___printf.html#ga63ca9a4c9e7dc22aee473ebb7dc66810">trio_printf</a></p>
<p><b>NOTES</b> </p>
<p>User-defined specifiers, <a class="el" href="group___user_defined.html#gabef3fc9260a3dcb58fafeacca586661e">trio_register</a>, and <a class="el" href="group___user_defined.html#ga8f3eaf6dcb41557d92f0f2236c4bcbb0">trio_unregister</a> are not thread-safe. In multi-threaded applications they must be guarded by mutexes. Trio provides two special callback functions, called ":enter" and ":leave", which are invoked every time a thread-unsafe operation is attempted. As the thread model is determined by the application, these callback functions must be implemented by the application.</p>
<p>The following callback functions are for demonstration-purposes only. Replace their bodies with locking and unlocking of a mutex to achieve thread-safety. </p>
<pre class="fragment">  static int enter_region(void *ref)
  {
    fprintf(stderr, "Enter Region\n");
    return 1;
  }

  static int leave_region(void *ref)
  {
    fprintf(stderr, "Leave Region\n");
    return 1;
  }
</pre><p> These two callbacks must be registered before other callbacks are registered. </p>
<pre class="fragment">  trio_register(enter_region, ":enter");
  trio_register(leave_region, ":leave");

  another_handle = trio_register(another_callback, NULL);
</pre> <h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gabef3fc9260a3dcb58fafeacca586661e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">trio_pointer_t trio_register </td>
          <td>(</td>
          <td class="paramtype">trio_callback_t&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register new user-defined specifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td></td></tr>
    <tr><td class="paramname">name</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle. </dd></dl>

<p>References <a class="el" href="group___static_strings.html#ga93f65da29dca8a7e901d6161323931c3">trio_duplicate()</a>, <a class="el" href="group___static_strings.html#gaa75c67cfe31da916009ee9fc2633ae30">trio_equal()</a>, and <a class="el" href="group___static_strings.html#ga390483a39e3210cd8a1bc5ed1c2a1639">trio_length()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8f3eaf6dcb41557d92f0f2236c4bcbb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void trio_unregister </td>
          <td>(</td>
          <td class="paramtype">trio_pointer_t&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister an existing user-defined specifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group___static_strings.html#ga886031dfdf8a6b818b320e242da204ad">trio_destroy()</a>.</p>

</div>
</div>
</div><!-- contents -->
<HR>
<center class="copyright">Copyright (C) 2001 - 2006 Bj&oslash;rn Reese and Daniel Stenberg.</center>
</body>
</html>
