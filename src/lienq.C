/******************************************************************************
**
**                 Nilpotent Quotient for Lie Rings
** lienq.c                                                      Csaba Schneider
**                                                           schcs@math.klte.hu
*/

#include "lienq.h"
#include <string.h>
#include <sys/types.h>
#include <time.h>
#include <unistd.h>

FILE *OutputFile = stdout;

/* A how-to-use messege. */
static void Usage(const char *msg) {
  if (msg != NULL)
    fprintf(stderr, "%s", msg);
  fprintf(stderr, "Usage: lienq [-G] [-D] [-A] [-Z] [-P] [-F <outputfile>] <inputfile> [<class>]\n");
  exit(3);
}

bool PrintZeros = false, Graded = false, Gap = false, PrintDefs = false;
unsigned Debug = 0;
unsigned Class;

int main(int argc, char **argv) {
  unsigned UpToClass = 0;
  char flags[24];
  flags[0] = '\0';
  int c;
  
  while ((c = getopt (argc, argv, "GDAZF:P")) != -1)
    switch (c) {
    case 'G':
      Graded = !Graded;
      strcat(flags, "-G ");
      break;
    case 'D':
      Debug++;
      strcat(flags, "-D ");
      break;
    case 'A':
      Gap = !Gap;
      strcat(flags, "-A ");
      break;
    case 'F':
      OutputFile = fopen(optarg, "w");
      if (OutputFile == NULL)
	Usage("Can't open output file.\n");
      strcat(flags, "-F ");
      break;
    case 'Z':
      PrintZeros = !PrintZeros;
      strcat(flags, "-Z ");
      break;
    case 'P':
      PrintDefs = !PrintDefs;
      strcat(flags, "-P ");
      break;
    default:
      Usage("Undefined flag.\n");
    }
  
  if (optind >= argc)
    Usage("Needs at least one name for input file.\n");

  char *InputFileName = argv[optind++];
  ReadPresentation(InputFileName);
  
  if (optind < argc)
    UpToClass = atoi(argv[optind]);

  char hostname[128];
  char timestring[26];
  time_t t = time((time_t *) 0);
  strcpy(timestring, ctime(&t));
  
  gethostname(hostname, 128);
  fprintf(OutputFile, "# The ANU Nilpotent Quotient Program\n"
	  "# for calculating nilpotent quotients in finitely presented Lie rings by Csaba Schneider.\n");
  fprintf(OutputFile, "# Program:    %s, version %s\n", argv[0], VERSION);
  fprintf(OutputFile, "# Machine:    %s\n", hostname);
  fprintf(OutputFile, "# Input file: %s\n", InputFileName);
  fprintf(OutputFile, "# Time:       %s", timestring);
  fprintf(OutputFile, "# Class:      %d\n", UpToClass);
  fprintf(OutputFile, "# Flags:      %s\n\n", flags);

  clock_t start = clock();

  InitPcPres();
  InitEpim();
  
  for (Class = 1; UpToClass == 0 || Class <= UpToClass; Class++) {
    unsigned OldNrPcGens = NrPcGens;

    if (Class >= 2)
      AddGen();

    InitStack();

    if (Class >= 2) {
      if (Graded) GradedTails(); else Tails();
    }
    
    InitMatrix();

    if (Class >= 2) {
      if (Graded) GradedConsistency(); else Consistency();
    }
    
    EvalAllRel();

    UpdatePcPres();

    FreeMatrix();
    
    if (NrCenGens == 0)
      break;

    ExtendPcPres();
  
    FreeStack();

    const char *stndrdth;
    if (Class % 10 == 1 && Class != 11)
      stndrdth = "st";
    else if (Class % 10 == 2 && Class != 12)
      stndrdth = "nd";
    else if (Class % 10 == 3 && Class != 13)
        stndrdth = "rd";
    else
      stndrdth = "th";

    fprintf(OutputFile, "# The %d%s factor is generated by %d generators of relative orders:\n# ", Class, stndrdth, Dimensions[Class]);
    for (unsigned i = OldNrPcGens + 1; i <= NrPcGens; i++)
      fprintf(OutputFile, "%ld%s", coeff_get_si(Coefficients[i]), i == NrPcGens ? "\n\n" : ", ");
  }

  InitStack();
  PrintPcPres();
  FreeStack();

  fprintf(OutputFile, "# Runtime: %.3g seconds\n",
          (clock() - start) / (float)CLOCKS_PER_SEC);

  FreePresentation();
  FreeEpim();
  FreePcPres();

  return 0;
}
