/******************************************************************************
**
**                 Nilpotent Quotient for Lie Rings
** lienq.c                                                      Csaba Schneider
**                                                           schcs@math.klte.hu
*/

#include "lienq.h"
#include <string.h>
#include <sys/types.h>
#include <time.h>
#include <unistd.h>

static char *ProgramName;
static unsigned UpToClass;
static char flags[24];

bool ZeroCenGens;
FILE *InputFile;
FILE *OutputFile;
char *InputFileName;
char *OutputFileName;

static char timestring[26];
char *gettime() {
  time_t t = time((time_t *)0);
  strcpy(timestring, ctime(&t));
  return timestring;
}

/* A how-to-use messege. */
static void Usage(const char *msg) {
  if (msg != NULL)
    fprintf(stderr, "%s", msg);
  fprintf(stderr, "Usage: lienq [-G] [-D] [-A] [-Z]\n");
  fprintf(stderr, "             [-F <outputfile>] <inputfile> [<class>]\n");
  exit(3);
}

static void PrintHeader() {
  char hostname[128];

  gethostname(hostname, 128);
  fprintf(OutputFile, "\n%s", "# The ANU Nilpotent Quotient Program");
  fprintf(OutputFile, "%s\n", " for calculating nilpotent quotients ");
  fprintf(OutputFile, "%s\n",
          "# in finitely presented Lie rings by Csaba Schneider.");
  fprintf(OutputFile, "%s %s\n", "# Version:  ", VERSION);
  fprintf(OutputFile, "%s %s\n", "# Program:  ", ProgramName);
  fprintf(OutputFile, "%s %s\n", "# Machine:  ", hostname);
  fprintf(OutputFile, "%s %s\n", "# Input file:", InputFileName);
  fprintf(OutputFile, "%s %s", "# Time:     ", gettime());
  fprintf(OutputFile, "%s %d\n", "# Class:    ", UpToClass);
  fprintf(OutputFile, "%s %s\n", "# Flags:    ", flags);
  fprintf(OutputFile, "\n%s\n", "# The factor rings are generated:\n");
}

bool Debug, PrintZeros, Graded, Gap;
unsigned Class;

int main(int argc, char **argv) {
  char c;
  bool PrintDefs = false;

  Debug = false;
  Graded = false;
  clock();
  OutputFileName = NULL;

  if (argc < 2)
    Usage(NULL);
  ProgramName = *(argv++);

  flags[0] = '\0';

  while (*((*argv)) == '-')
    switch (*++(*argv++)) {
    case 'G':
      Graded = !Graded;
      argc--;
      strcat(flags, "-G ");
      break;
    case 'D':
      Debug = !Debug;
      argc--;
      strcat(flags, "-D ");
      break;
    case 'A':
      Gap = !Gap;
      argc--;
      strcat(flags, "-A ");
      break;
    case 'F':
      OutputFileName = *(argv++);
      argc--;
      argc--;
      strcat(flags, "-F ");
      break;
    case 'Z':
      PrintZeros = !PrintZeros;
      argc--;
      strcat(flags, "-Z ");
      break;
    case 'P':
      PrintDefs = !PrintDefs;
      argc--;
      strcat(flags, "-P ");
      break;
    default:
      Usage("Undefined flag\n");
    }
  InputFileName = *(argv++);
  if (argc == 3)
    while ((c = *((*argv)++)) != '\0')
      UpToClass = 10 * UpToClass + c - '0';
  else
    UpToClass = 0;

  if (OutputFileName != NULL) {
    OutputFile = fopen(OutputFileName, "w");
    if (OutputFile == NULL)
      Usage("Can't open output file.\n");
  } else
    OutputFile = stdout;

  setbuf(OutputFile, NULL);

  InputFile = fopen(InputFileName, "r");
  if (InputFile == NULL)
    Usage("Can't open input file.\n");

  PrintHeader();

  ZeroCenGens = false;

  Class = 1;

  ReadPresentation();

  fclose(InputFile);

  InitPcPres();

  InitEpim();
  
  InitMatrix();

  EvalAllRel();

  UpdatePcPres();

  FreeMatrix();

  ExtendPcPres();
  
  fprintf(OutputFile, "#  The Abelian factor is generated by %d generators of relative orders:\n#  ", NrPcGens);

  if (NrPcGens > 0) {
    for (unsigned i = 1; i <= Dimensions[1]; i++)
      fprintf(OutputFile, "%ld%s", Coefficients[i].data,
              i < Dimensions[1] ? ", " : "");
  }
  fprintf(OutputFile, "\n\n");

  for (Class = 2; UpToClass == 0 || Class <= UpToClass; Class++) {
    unsigned OldNrPcGens = NrPcGens;
    AddGen();

    if (Graded)
      GradedTails();
    else
      Tails();

    InitMatrix();
    
    if (Graded)
      GradedConsistency();
    else
      Consistency();

    EvalAllRel();

    UpdatePcPres();

    FreeMatrix();
    
    if (ZeroCenGens)
      break;

    ExtendPcPres();

    const char *stndrdth;
    if (Class % 10 == 1 && Class != 11)
      stndrdth = "st";
    else if (Class % 10 == 2 && Class != 12)
      stndrdth = "nd";
    else if (Class % 10 == 3 && Class != 13)
        stndrdth = "rd";
    else
      stndrdth = "th";

    fprintf(OutputFile, "#  The %d%s factor is generated by ", Class, stndrdth);
    fprintf(OutputFile, "%d generators of relative orders:\n#  ",
            Dimensions[Class]);
    for (unsigned i = OldNrPcGens + 1; i <= NrPcGens - 1; i++)
      fprintf(OutputFile, "%ld, ", Coefficients[i].data);
    fprintf(OutputFile, "%ld\n\n", Coefficients[NrPcGens].data);
  }
  PrintPcPres();

  if (PrintDefs)
    PrintDefinitions();

  FreePresentation();
  FreeEpim();
  FreePcPres();

  fprintf(OutputFile, "# Runtime: %.3g seconds\n",
          clock() / (float)CLOCKS_PER_SEC);
  exit(0);
}
